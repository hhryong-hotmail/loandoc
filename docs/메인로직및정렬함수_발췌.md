# 메인 로직 및 정렬 함수 발췌

## 1. 신용대출 메인 로직 및 정렬 함수

### 1.1 서버 측: 금융사 데이터 수신 및 처리

#### 1.1.1 LoanEstimateServlet.java - 데이터 수신 및 검증

```30:123:server/src/main/java/com/loandoc/LoanEstimateServlet.java
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
        // Set request encoding to UTF-8 BEFORE reading any data
        req.setCharacterEncoding("UTF-8");
        
        res.setContentType("application/json");
        res.setCharacterEncoding("UTF-8");

        try {
            // Parse request body
            ObjectNode requestBody = mapper.readValue(req.getReader(), ObjectNode.class);

            // Short debug: write received request summary to a debug log file so we can inspect server-side failures
            try {
                String visaTypeDbg = requestBody.has("visaType") ? requestBody.get("visaType").asText() : "";
                String natDbg = requestBody.has("nationality") ? requestBody.get("nationality").asText() : "";
                String dbg = String.format("%s - REQ loginId=%s visaType=%s nationality=%s\n",
                        java.time.ZonedDateTime.now().toString(),
                        (requestBody.has("loginId") ? requestBody.get("loginId").asText() : ""),
                        visaTypeDbg, natDbg);
                writeDebugLog(dbg, null);
            } catch (Throwable _t) {
                // avoid failing request if debug logging fails
            }

            String loginId = requestBody.has("loginId") ? requestBody.get("loginId").asText() : null;
            String nationality = requestBody.has("nationality") ? requestBody.get("nationality").asText() : null;
            Integer remainMonths = requestBody.has("remainMonths") ? requestBody.get("remainMonths").asInt() : null;
            Double annualIncome = requestBody.has("annualIncome") ? requestBody.get("annualIncome").asDouble() : null;
            Integer age = requestBody.has("age") ? requestBody.get("age").asInt() : null;
            Integer workingMonths = requestBody.has("workingMonths") ? requestBody.get("workingMonths").asInt() : null;
            String visaType = requestBody.has("visaType") ? requestBody.get("visaType").asText() : null;
            String healthInsurance = requestBody.has("healthInsurance") ? requestBody.get("healthInsurance").asText() : null;

            // Validate required fields
            if (loginId == null || nationality == null || remainMonths == null
                    || annualIncome == null || age == null || workingMonths == null || visaType == null) {
                res.setStatus(400);
                ObjectNode error = mapper.createObjectNode();
                error.put("ok", false);
                error.put("error", "모든 필드가 필요합니다");
                res.getWriter().write(mapper.writeValueAsString(error));
                return;
            }

            // Normalize visa type
            String normalizedVisaType = normalizeVisaType(visaType);

            // Bank configurations
            List<BankConfig> banks = getBankConfigurations();

            // Process each bank
            ArrayNode results = mapper.createArrayNode();
            for (BankConfig bank : banks) {
                ObjectNode result = processBank(bank, nationality, remainMonths, annualIncome, age, workingMonths, normalizedVisaType, healthInsurance);
                results.add(result);
            }

            // Sort by rank
            List<ObjectNode> sortedResults = new ArrayList<>();
            results.forEach(node -> sortedResults.add((ObjectNode) node));
            sortedResults.sort((a, b) -> {
                int rankA = a.has("rank") && !a.get("rank").isNull() ? a.get("rank").asInt() : 999;
                int rankB = b.has("rank") && !b.get("rank").isNull() ? b.get("rank").asInt() : 999;
                return Integer.compare(rankA, rankB);
            });

            ArrayNode finalResults = mapper.createArrayNode();
            sortedResults.forEach(finalResults::add);

            // Wrap in response object
            ObjectNode response = mapper.createObjectNode();
            response.set("banks", finalResults);

            res.getWriter().write(mapper.writeValueAsString(response));

        } catch (Exception e) {
            // print to console and also write full stacktrace to debug file
            e.printStackTrace();
            try {
                StringWriter sw = new StringWriter();
                PrintWriter pw = new PrintWriter(sw);
                e.printStackTrace(pw);
                writeDebugLog("EXCEPTION during doPost:\n", sw.toString());
            } catch (Throwable _t) {
                // ignore
            }
            res.setStatus(500);
            ObjectNode error = mapper.createObjectNode();
            error.put("ok", false);
            error.put("error", "server error");
            res.getWriter().write(mapper.writeValueAsString(error));
        }
    }
```

**설명:**
- 고객으로부터 입력받은 데이터를 JSON 형식으로 파싱
- 필수 필드 검증 수행 (loginId, nationality, remainMonths, annualIncome, age, workingMonths, visaType)
- 비자 종류 정규화 처리
- 각 은행별 설정 정보를 가져와서 조건 검증 및 예상 한도/금리 계산
- 서버 측에서는 rank 기준으로 정렬하여 응답 (기본 정렬)

#### 1.1.2 예상 한도 계산 로직

```452:476:server/src/main/java/com/loandoc/LoanEstimateServlet.java
        // 예상한도 계산: 연소득 × 잔여체류기간 × 가중치 / 10
        // 단, 최고한도를 초과할 수 없음
        double calculatedLimit = (annualIncome * remainMonths * bank.weightFactor) / 10.0;
        double finalLimit = Math.min(calculatedLimit, bank.maxLimit);
        
        // 소수점 이하 반올림
        finalLimit = Math.round(finalLimit);
        
        result.put("estimatedLimit", finalLimit);
        
        if (bank.estimatedRate != null) {
            // 소수점 2자리까지 반올림
            double roundedRate = Math.round(bank.estimatedRate * 100.0) / 100.0;
            result.put("estimatedRate", roundedRate);
        } else {
            result.putNull("estimatedRate");
        }

        if (bank.rank != null) {
            result.put("rank", bank.rank);
        } else {
            result.putNull("rank");
        }

        return result;
```

**설명:**
- 예상 한도 계산식: 연소득 × 잔여체류기간 × 가중치 / 10
- 계산된 한도가 최고한도를 초과하지 않도록 제한
- 소수점 처리: 한도는 반올림, 금리는 소수점 2자리까지 반올림

### 1.2 클라이언트 측: 정렬 및 화면 표시

#### 1.2.1 금융사 데이터 수신

```937:969:server/src/main/webapp/loanAppl.html
                        const res = await fetch('/server/api/server/loan-estimate', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify(requestData)
                        });
                        if(!res.ok) throw new Error('서버 오류');
                        const result = await res.json();
                        // Client-side safeguards and immediate Jeonbuk popups removed per request.
                        // Remove any cached result then store fresh result in sessionStorage
                        sessionStorage.removeItem('loanEstimateResult');
                        sessionStorage.removeItem('loanEstimateInput');
                        // Jeonbuk immediate popup logic removed.
                        sessionStorage.setItem('loanEstimateResult', JSON.stringify(result));
                        sessionStorage.setItem('loanEstimateInput', JSON.stringify({
                            loginId,
                            nationality,
                            remainMonths,
                            annualIncome,
                            age,
                            workingMonths,
                            visaType
                        }));
                        // Display result in the same page
                        displayLoanResult(result, {
                            loginId,
                            nationality,
                            remainMonths,
                            annualIncome,
                            age,
                            workingMonths,
                            visaType,
                            healthInsurance
                        });
```

**설명:**
- 서버로 POST 요청을 전송하여 대출 상품 목록 조회
- 응답 결과를 sessionStorage에 저장하여 정렬 옵션 변경 시 재사용
- `displayLoanResult` 함수를 호출하여 결과를 화면에 표시

#### 1.2.2 정렬 옵션 확인 및 정렬 함수

```1228:1379:server/src/main/webapp/loanAppl.html
            // Get current sort option
            const sortByRate = document.querySelector('input[name="sortOption"]:checked')?.value === 'rate';
            
            // Populate input row
            document.getElementById('input-visa').textContent = inputData.visaType || '-';
            document.getElementById('input-country').textContent = inputData.nationality || '-';
            document.getElementById('input-age').textContent = inputData.age || '-';
            
            document.getElementById('input-income').textContent = (inputData.annualIncome || 0).toLocaleString() + '만원';
            
            // Working months
            document.getElementById('input-working-months').textContent = (inputData.workingMonths || 0) + '개월';
            
            // Health insurance
            document.getElementById('input-health-insurance').textContent = inputData.healthInsurance || '-';
            
            // Remain months (잔여체류기간)
            document.getElementById('input-remain-months').textContent = (inputData.remainMonths || 0) + '개월';
            
            // Clear previous results
            resultTbody.innerHTML = '';
            console.log("하현용.............")
            // Apply 전북은행 client-side rules: 서버 응답을 덮어쓰지 않되,
            // 전북은행 항목이 규칙에 걸리면 country.valid=false로 표시하여
            // UI에서 '불가'로 보이게 합니다. 맵은 JEONBUK_BLOCK_RULES에 있음.
            try {
                if (result && Array.isArray(result.banks) && inputData) {
                    result.banks.forEach(bank => {
                        if (!bank) return;
                        try {
                            console.log('[Bank row]', 'bankName=', bank.bankName, 'country.valid=', bank.country && bank.country.valid, 'country.error=', bank.country && bank.country.error);
                        } catch (lgErr) {
                            console.debug('Bank row log error', lgErr);
                        }
                        if (!bank.bankName) return;
                        if (String(bank.bankName).trim() === '전북은행') {
                            // inputData.nationality, inputData.visaType 사용
                            const nat = inputData.nationality || inputData.nationalityName || inputData.country || '';
                            const visa = inputData.visaType || inputData.visa || '';
                            try {
                                // 항상 은행명/비자/국가 정보를 내부 필드에 남겨 UI나 디버그에서 표시 가능하도록 함
                                bank._jeonbuk_info = {
                                    bankName: bank.bankName || '전북은행',
                                    visa: String(visa).trim(),
                                    nationality: String(nat).trim()
                                };

                                // 디버그: 규칙 매칭 여부를 콘솔에 남겨 문제를 진단하기 쉽도록 함
                                const blockedInitial = isJeonbukBlockedByRule(nat, visa);
                                let blocked = blockedInitial;

                                // 예외: 전북은행에서 F4 + China 는 허용되어야 함
                                try {
                                    const natNorm = normalizeCountryName(nat);
                                    const visaNorm = String(visa || '').trim().toUpperCase().replace(/[-\s]/g, '');
                                    const isF4 = visaNorm === 'F4' || visaNorm === 'F-4' || /^F4/.test(visaNorm);
                                    if (isF4 && natNorm === 'china') {
                                        // 강제 허용
                                        blocked = false;
                                        console.log('[Jeonbuk override] Allowing F4 + China -> blocked forced false');
                                    }
                                } catch (exOverride) {
                                    console.debug('Jeonbuk override check error', exOverride);
                                }
                                try {
                                    console.log('[Jeonbuk check]', 'bankName=', bank.bankName, 'visa=', String(visa).trim(), 'nationality=', String(nat).trim(), 'blockedInitial=', blockedInitial, 'blockedAfterOverride=', blocked);
                                } catch (lgErr) {
                                    // 로그 중 에러가 나더라도 흐름은 계속되도록 함
                                    console.debug('Jeonbuk 로그 에러', lgErr);
                                }
                                try {
                                    console.log('[Jeonbuk check]', 'bankName=', bank.bankName, 'visa=', String(visa).trim(), 'nationality=', String(nat).trim(), 'blocked=', blocked);
                                } catch (lgErr) {
                                    // 로그 중 에러가 나더라도 흐름은 계속되도록 함
                                    console.debug('Jeonbuk 로그 에러', lgErr);
                                }

                                if (blocked) {
                                    bank.country = bank.country || {};
                                    bank.country.valid = false;
                                    // 사용자에게 명확히 보이도록 은행명/비자/국가 정보를 포함한 메시지로 설정
                                    const visaDisplay = String(visa).trim() || '-';
                                    const natDisplay = String(nat).trim() || '-';
                                    bank.country.error = bank.country.error || (bank.bankName + ' - ' + visaDisplay + ' - ' + natDisplay + ' : 대출불가');
                                    bank._jeonbukBlocked = true;
                                } else {
                                    bank._jeonbukBlocked = false;
                                    // 만약 서버가 country.valid=false로 내려줬다면, 클라이언트 예외에 의해 허용 처리
                                    try {
                                        if (bank.country && bank.country.valid === false) {
                                            bank.country.valid = true;
                                            // 이전 에러 메시지는 보존하지 않으려면 비우거나 주석 처리
                                            bank.country.error = '';
                                            console.log('[Jeonbuk client override] Cleared server country.error for', bank.bankName);
                                        }
                                    } catch (clrErr) {
                                        console.debug('Error clearing server country.error after override', clrErr);
                                    }
                                }
                            } catch (e) {
                                console.error('전북은행 규칙 적용/메시지 작성 중 오류', e);
                            }
                        }
                    });
                }
            } catch (e) {
                console.error('전북은행 규칙 적용 중 오류', e);
            }
            // Populate result rows
            if(result && Array.isArray(result.banks)){
                // Sort banks: '가능' first, '불가' last
                // Within '가능' banks, sort by estimatedRate (if sortByRate) or estimatedLimit (if sortByLimit)
                const sortedBanks = result.banks.slice().sort((a, b) => {
                    const hasFailureA = 
                        (a.visaType && !a.visaType.valid) ||
                        (a.country && !a.country.valid) ||
                        (a.age && !a.age.valid) ||
                        (a.annualIncome && !a.annualIncome.valid) ||
                        (a.employmentDate && !a.employmentDate.valid) ||
                        (a.visaExpiry && !a.visaExpiry.valid) ||
                        (a.healthInsurance && !a.healthInsurance.valid);
                    
                    const hasFailureB = 
                        (b.visaType && !b.visaType.valid) ||
                        (b.country && !b.country.valid) ||
                        (b.age && !b.age.valid) ||
                        (b.annualIncome && !b.annualIncome.valid) ||
                        (b.employmentDate && !b.employmentDate.valid) ||
                        (b.visaExpiry && !b.visaExpiry.valid) ||
                        (b.healthInsurance && !b.healthInsurance.valid);
                    
                    // '가능' (no failure) comes before '불가' (has failure)
                    if (!hasFailureA && hasFailureB) return -1;
                    if (hasFailureA && !hasFailureB) return 1;
                    
                    // If both are '가능', sort by selected option
                    if (!hasFailureA && !hasFailureB) {
                        if (sortByRate) {
                            // Sort by rate (lower rate first)
                            const rateA = a.estimatedRate || 999;
                            const rateB = b.estimatedRate || 999;
                            return rateA - rateB;
                        } else {
                            // Sort by limit (higher limit first)
                            const limitA = a.estimatedLimit || 0;
                            const limitB = b.estimatedLimit || 0;
                            return limitB - limitA;
                        }
                    }
                    
                    return 0;
                });
```

**설명:**
- 라디오 버튼에서 선택된 정렬 옵션 확인 (`sortByRate`: 금리순 여부)
- 각 은행의 검증 실패 여부 확인 (비자종류, 국적, 나이, 연소득, 재직일자, 비자만료일, 의료보험)
- 정렬 우선순위:
  1. '가능' 상태인 은행이 '불가' 상태인 은행보다 먼저 표시
  2. '가능' 상태인 은행들 중에서:
     - 금리순 선택 시: 금리가 낮은 순서대로 정렬 (오름차순)
     - 한도순 선택 시: 한도가 높은 순서대로 정렬 (내림차순)

#### 1.2.3 정렬 결과 화면 표시

```1381:1517:server/src/main/webapp/loanAppl.html
                
                // Track rank for '가능' banks only
                // 테스트 모드: 동일한 값일 때 같은 순위 부여 (1,2,2,4,5 형식)
                let currentRank = 1;
                let prevValue = null; // 이전 '가능' 은행의 정렬 기준 값 저장
                
                sortedBanks.forEach((bank, idx) => {
                    
                    const tr = document.createElement('tr');
                    
                    // Check if this bank has any failure
                    const hasFailure = 
                        (bank.visaType && !bank.visaType.valid) ||
                        (bank.country && !bank.country.valid) ||
                        (bank.age && !bank.age.valid) ||
                        (bank.annualIncome && !bank.annualIncome.valid) ||
                        (bank.employmentDate && !bank.employmentDate.valid) ||
                        (bank.visaExpiry && !bank.visaExpiry.valid) ||
                        (bank.healthInsurance && !bank.healthInsurance.valid);
                    
                    // Rank column - show number for '가능', 'X' for '불가'
                    const tdRank = document.createElement('td');
                    if (hasFailure) {
                        tdRank.textContent = 'X';
                        tdRank.style.color = 'red';
                        tdRank.style.fontWeight = 'bold';
                    } else {
                        // 동일한 값일 때 같은 순위 부여 (1,2,2,4,5 형식)
                        const currentValue = sortByRate ? (bank.estimatedRate || 999) : (bank.estimatedLimit || 0);
                        
                        // 첫 번째 '가능' 항목이 아니고 이전 값과 다르면 순위 증가
                        if (prevValue !== null && prevValue !== currentValue) {
                            currentRank++;
                        }
                        
                        tdRank.textContent = currentRank;
                        prevValue = currentValue; // 현재 값을 이전 값으로 저장
                    }
                    tr.appendChild(tdRank);
                    
                    // Bank name
                    const tdBank = document.createElement('td');
                    tdBank.textContent = bank.bankName || '-';
                    // If Jeonbuk rule matched or server provided a country.error, show a visible red note under the bank name
                        try {
                        // 원본 메시지 취득
                        let noteText = ((bank._jeonbukBlocked ? (bank.country && bank.country.error) : (bank.country && bank.country.error)) || '').trim();
                        // 'E국가' 또는 'E국가비자' 전체 단독 메시지는 삭제
                        if (noteText === 'E국가' || noteText === 'E국가비자') {
                            noteText = '';
                        }

                        // 메시지에 '대출불가' 텍스트가 포함된 경우 (예: "전북은행 - F4 - Cambodia : 대출불가")
                        // 사용자 요청에 따라 해당 전체 메시지는 표시하지 않음
                        if (noteText && noteText.indexOf('대출불가') !== -1) {
                            noteText = '';
                        } else {
                            // 내부에 포함된 E국가 토큰만 제거하고 나머지 메시지는 유지
                            noteText = noteText.replace(/E국가비자/g, '').replace(/E국가/g, '').replace(/\s{2,}/g, ' ').trim();
                        }

                        if (noteText) {
                            const note = document.createElement('div');
                            note.style.fontSize = '0.8rem';
                            note.style.color = 'red';
                            note.style.marginTop = '4px';
                            note.textContent = noteText;
                            tdBank.appendChild(note);
                        }
                    } catch (noteErr) {
                        console.debug('Bank note render error', noteErr);
                    }
                    tr.appendChild(tdBank);

                    // 결과 (Result) - 'X'가 하나라도 있으면 '불가' 표시
                    const tdResult = document.createElement('td');
                    if (hasFailure) {
                        tdResult.textContent = '불가';
                        tdResult.style.color = 'red';
                        tdResult.style.fontWeight = 'bold';
                    } else {
                        tdResult.textContent = '가능';
                        tdResult.style.color = 'green';
                        tdResult.style.fontWeight = 'bold';
                    }
                    tr.appendChild(tdResult);

                    // 신청 컬럼: '가능'일 때만 신청 버튼을 표시
                    const tdApply = document.createElement('td');
                    if (!hasFailure) {
                        const applyBtn = document.createElement('button');
                        applyBtn.type = 'button';
                        applyBtn.className = 'loan-apply-btn';
                        applyBtn.textContent = '신청';
                        applyBtn.style.background = '#28a745';
                        applyBtn.style.color = '#fff';
                        applyBtn.style.border = 'none';
                        applyBtn.style.padding = '6px 10px';
                        applyBtn.style.borderRadius = '6px';
                        applyBtn.style.cursor = 'pointer';
                        applyBtn.addEventListener('click', function(e){
                            e.preventDefault();
                            // store current bank + input for submission
                            window._loanApplyContext = { bank: bank, input: lastInputData };
                            openApplyConfirmModal(bank, lastInputData);
                        });
                        tdApply.appendChild(applyBtn);
                    } else {
                        tdApply.textContent = '';
                    }
                    tr.appendChild(tdApply);

                    // Estimated limit
                    const tdLimit = document.createElement('td');
                    if (hasFailure) {
                        // 대출불가 판정 시 예상한도 표시 안 함
                        tdLimit.textContent = '-';
                    } else if (bank.bankName === '예가람저축은행') {
                        // 서버에서 계산된 예상한도 사용 (최고한도 4000만원 기준)
                        tdLimit.textContent = bank.estimatedLimit ? bank.estimatedLimit.toLocaleString() + '만원' : '-';
```

**설명:**
- 정렬된 은행 목록을 순회하며 테이블 행(tr) 생성
- 순위 표시: '가능' 상태는 숫자로 표시 (동일한 값일 때 같은 순위 부여), '불가' 상태는 'X'로 표시
- 은행명, 결과 상태('가능'/'불가'), 예상 한도, 예상 금리 등을 표시
- '가능' 상태인 경우에만 신청 버튼 표시

#### 1.2.4 정렬 옵션 변경 이벤트 처리

```1961:1978:server/src/main/webapp/loanAppl.html
                // Add event listeners for sort option radio buttons (자동 목록조회 제거)
                document.querySelectorAll('input[name="sortOption"]').forEach(radio => {
                    radio.addEventListener('change', function() {
                        // 정렬 옵션이 변경되면 저장된 결과를 다시 표시
                        if (lastLoanResult && lastInputData) {
                            displayLoanResult(lastLoanResult, lastInputData);
                        }
                    });
                });
```

**설명:**
- 라디오 버튼 변경 시 저장된 결과를 재사용하여 정렬만 다시 수행
- 서버 재요청 없이 클라이언트 측에서 정렬 처리

---

## 2. 담보대출 메인 로직 및 정렬 함수

### 2.1 서버 측: 대출 상담 요청 목록 수신

#### 2.1.1 LoanDashboardServlet.java - 목록 조회

```150:206:server/src/main/java/com/loandoc/LoanDashboardServlet.java
    private void listRequests(String q, String reqType, String order, HttpServletResponse resp, ObjectMapper mapper) throws IOException {
        Connection conn = null;
        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
            StringBuilder sql = new StringBuilder("SELECT req_id, req_login, counseler, name, phone_number, nationality, req_type, title, content, created_at, updated_at FROM loan_dashboard WHERE 1=1");
            List<String> params = new ArrayList<>();
            if (reqType != null && !reqType.trim().isEmpty() && !reqType.equals("전체")) {
                sql.append(" AND req_type = ?");
                params.add(reqType);
            }
            if (q != null && !q.trim().isEmpty()) {
                sql.append(" AND (title ILIKE ? OR content ILIKE ? OR req_login ILIKE ? OR name ILIKE ?)");
                String p = "%" + q + "%";
                params.add(p); params.add(p); params.add(p); params.add(p);
            }
            // Allow optional ordering by req_id. Default is DESC (new requirement).
            String ord = (order != null && order.equalsIgnoreCase("asc")) ? "ASC" : "DESC";
            sql.append(" ORDER BY req_id " + ord);

            stmt = conn.prepareStatement(sql.toString());
            for (int i = 0; i < params.size(); i++) stmt.setString(i+1, params.get(i));

            rs = stmt.executeQuery();
            ArrayNode rows = mapper.createArrayNode();
            while (rs.next()) {
                ObjectNode row = mapper.createObjectNode();
                row.put("req_id", rs.getInt("req_id"));
                row.put("req_login", rs.getString("req_login"));
                row.put("counseler", rs.getString("counseler"));
                row.put("name", rs.getString("name"));
                row.put("phone_number", rs.getString("phone_number"));
                row.put("nationality", rs.getString("nationality"));
                row.put("req_type", rs.getString("req_type"));
                row.put("title", rs.getString("title"));
                row.put("content", rs.getString("content"));
                row.put("created_at", rs.getTimestamp("created_at") != null ? rs.getTimestamp("created_at").toString() : "");
                row.put("updated_at", rs.getTimestamp("updated_at") != null ? rs.getTimestamp("updated_at").toString() : "");
                rows.add(row);
            }

            ObjectNode response = mapper.createObjectNode();
            response.put("ok", true);
            response.set("rows", rows);
            resp.setStatus(HttpServletResponse.SC_OK);
            resp.getWriter().write(mapper.writeValueAsString(response));

        } catch (SQLException e) {
            e.printStackTrace();
            resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            resp.getWriter().write("{\"ok\":false,\"error\":\"Database error: " + e.getMessage() + "\"}");
        } finally {
            closeResources(rs, stmt, conn);
        }
    }
```

**설명:**
- 데이터베이스에서 대출 상담 요청 목록 조회
- 검색어(q)와 요청 유형(req_type)으로 필터링
- 기본 정렬: req_id 기준 내림차순(DESC) - 최신순
- 선택적 정렬: order 파라미터로 오름차순(ASC) 지정 가능

### 2.2 클라이언트 측: 목록 표시

#### 2.2.1 데이터 수신 및 표시

```230:285:server/src/main/webapp/loanDashboard.html
async function loadPosts(){
                const q = encodeURIComponent(searchInput.value || '');
                let url = `/server/api/loan_dashboard?q=${q}`;
                const t = filterType.value || '';
                if (t && t !== '전체') {
                    url += `&req_type=${encodeURIComponent(t)}`;
                }
                try{
                    const r = await fetch(url);
                    const j = await r.json();
                    if(!j.ok) throw new Error(j.error || 'load failed');
                    renderPosts(j.rows || []);
                }catch(e){
                    alert('목록 불러오기 실패: '+e.message);
                }
            }
            function formatDateTime(val){
                if(!val) return '';
                // If already a Date object
                try{
                    const d = new Date(val);
                    if(isNaN(d)){
                        // If value is YYYY-MM-DD, return with 00:00
                        const s = String(val).trim();
                        if(/^\d{4}-\d{2}-\d{2}$/.test(s)) return s + ' 00:00';
                        return s;
                    }
                    const pad = (n) => String(n).padStart(2,'0');
                    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
                }catch(e){ return String(val); }
            }

            function renderPosts(rows){
                postsBody.innerHTML = '';
                if(!rows || rows.length===0){
                    postsBody.innerHTML = `<tr><td colspan="5" style="padding:12px;text-align:center;color:#666">등록된 글이 없습니다.</td></tr>`;
                    return;
                }
                for(const r of rows){
                    const tr = document.createElement('tr');
                    // Only allow edit/delete for the author who created the post (if logged in)
                    const allowEdit = currentUser && String(currentUser) === String(r.req_login);
                    tr.innerHTML = `
                        <td style="padding:8px;border-bottom:1px solid #f1f1f1">${r.req_id}</td>
                        <td style="padding:8px;border-bottom:1px solid #f1f1f1">${formatDateTime(r.created_at || r.updated_at)}</td>
                        <td style="padding:8px;border-bottom:1px solid #f1f1f1">${escapeHtml(r.req_login || '')}</td>
                        <td style="padding:8px;border-bottom:1px solid #f1f1f1">${r.req_type || ''}</td>
                        <td style="padding:8px;border-bottom:1px solid #f1f1f1"><a href="#" class="view-link" data-id="${r.req_id}">${escapeHtml(r.title || '')}</a></td>
                    `;
                    postsBody.appendChild(tr);
                }
                // attach click handlers to title links for viewing
                postsBody.querySelectorAll('a.view-link').forEach(a=>{
                    a.addEventListener('click', (ev)=>{ ev.preventDefault(); const id = a.getAttribute('data-id'); viewPost(id); });
                });
            }
```

**설명:**
- 서버로 GET 요청을 전송하여 대출 상담 요청 목록 조회
- 검색어와 필터 조건을 URL 파라미터로 전달
- 서버에서 정렬된 결과를 받아서 테이블에 표시
- 각 행의 제목 클릭 시 상세 정보 조회

---

## 3. 메인 로직 흐름도 요약

### 3.1 신용대출 흐름도

```
고객 입력 데이터
    ↓
서버 데이터 수신 (LoanEstimateServlet.doPost)
    ↓
필수 필드 검증
    ↓
각 은행별 조건 검증 및 예상 한도/금리 계산
    ↓
서버 측 rank 기준 정렬
    ↓
클라이언트 응답 수신
    ↓
if (한도순 선택)
    → 한도순 정렬 함수 호출 (내림차순)
else if (금리순 선택)
    → 금리순 정렬 함수 호출 (오름차순)
    ↓
'가능' 상태 우선 정렬 ('불가'는 하단에 배치)
    ↓
정렬 결과를 화면에 표시
```

### 3.2 담보대출 흐름도

```
고객 검색/필터 조건
    ↓
서버 데이터 수신 (LoanDashboardServlet.listRequests)
    ↓
데이터베이스 쿼리 (검색어, 요청 유형 필터링)
    ↓
req_id 기준 내림차순 정렬 (최신순)
    ↓
클라이언트 응답 수신
    ↓
정렬 결과를 화면에 표시
```

---

## 참고사항

1. **신용대출 정렬 특징:**
   - 서버는 기본적으로 rank 기준으로 정렬하여 응답
   - 클라이언트에서 사용자 선택에 따라 한도순 또는 금리순으로 재정렬
   - '가능' 상태인 은행이 항상 '불가' 상태인 은행보다 먼저 표시됨
   - 동일한 값일 때 같은 순위 부여 (예: 1, 2, 2, 4, 5)

2. **담보대출 정렬 특징:**
   - 서버 측에서 req_id 기준 내림차순 정렬 (최신순)
   - 클라이언트 측 추가 정렬 없음
   - 검색 및 필터링 기능 제공

3. **성능 최적화:**
   - 신용대출: 정렬 옵션 변경 시 서버 재요청 없이 클라이언트 측에서 정렬 처리
   - 담보대출: 데이터베이스 레벨에서 정렬 처리하여 효율성 확보




