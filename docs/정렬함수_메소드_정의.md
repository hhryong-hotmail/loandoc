# 정렬 함수 및 메소드 정의

## 1. 신용대출 정렬 함수/메소드

### 1.1 서버 측 정렬 메소드

#### 1.1.1 sortByRank() - Rank 기준 정렬

**위치:** `server/src/main/java/com/loandoc/LoanEstimateServlet.java` (88-95줄)

**정의:**
```java
// Sort by rank
List<ObjectNode> sortedResults = new ArrayList<>();
results.forEach(node -> sortedResults.add((ObjectNode) node));
sortedResults.sort((a, b) -> {
    int rankA = a.has("rank") && !a.get("rank").isNull() ? a.get("rank").asInt() : 999;
    int rankB = b.has("rank") && !b.get("rank").isNull() ? b.get("rank").asInt() : 999;
    return Integer.compare(rankA, rankB);
});
```

**매개변수:**
- `a`: ObjectNode - 비교할 첫 번째 은행 정보 객체
- `b`: ObjectNode - 비교할 두 번째 은행 정보 객체

**반환값:**
- `int`: 비교 결과
  - 음수: a가 b보다 앞에 위치 (rankA < rankB)
  - 0: 같은 순위 (rankA == rankB)
  - 양수: a가 b보다 뒤에 위치 (rankA > rankB)

**정렬 기준:**
- `rank` 필드 값을 기준으로 오름차순 정렬
- `rank`가 null인 경우 999로 처리하여 가장 뒤에 배치

**사용 위치:**
- `LoanEstimateServlet.doPost()` 메소드 내
- 서버에서 클라이언트로 응답 전 기본 정렬 수행

---

#### 1.1.2 sortByInterestRate() - 금리 기준 정렬 (은행 설정 내부)

**위치:** `server/src/main/java/com/loandoc/LoanEstimateServlet.java` (207-217줄)

**정의:**
```java
// Assign ranks to null-rank banks based on interest rate
List<BankConfig> middleBanks = new ArrayList<>();
for (BankConfig bank : banks) {
    if (bank.rank == null && bank.estimatedRate != null) {
        middleBanks.add(bank);
    }
}
middleBanks.sort((a, b) -> Double.compare(a.estimatedRate, b.estimatedRate));
for (int i = 0; i < middleBanks.size(); i++) {
    middleBanks.get(i).rank = i + 2;
}
```

**매개변수:**
- `a`: BankConfig - 비교할 첫 번째 은행 설정 객체
- `b`: BankConfig - 비교할 두 번째 은행 설정 객체

**반환값:**
- `int`: 비교 결과
  - 음수: a가 b보다 앞에 위치 (a.estimatedRate < b.estimatedRate)
  - 0: 같은 금리 (a.estimatedRate == b.estimatedRate)
  - 양수: a가 b보다 뒤에 위치 (a.estimatedRate > b.estimatedRate)

**정렬 기준:**
- `estimatedRate` 필드 값을 기준으로 오름차순 정렬 (낮은 금리 우선)
- rank가 null인 은행들에 대해서만 적용
- 정렬 후 rank 값을 2부터 순차적으로 할당 (1위는 KB저축은행 고정)

**사용 위치:**
- `LoanEstimateServlet.getBankConfigurations()` 메소드 내
- 은행 설정 초기화 시 rank가 지정되지 않은 은행들의 순위 결정

---

### 1.2 클라이언트 측 정렬 함수

#### 1.2.1 sortBanksByOption() - 한도순/금리순 정렬

**위치:** `server/src/main/webapp/loanAppl.html` (1340-347줄)

**정의:**
```javascript
const sortedBanks = result.banks.slice().sort((a, b) => {
    const hasFailureA = 
        (a.visaType && !a.visaType.valid) ||
        (a.country && !a.country.valid) ||
        (a.age && !a.age.valid) ||
        (a.annualIncome && !a.annualIncome.valid) ||
        (a.employmentDate && !a.employmentDate.valid) ||
        (a.visaExpiry && !a.visaExpiry.valid) ||
        (a.healthInsurance && !a.healthInsurance.valid);
    
    const hasFailureB = 
        (b.visaType && !b.visaType.valid) ||
        (b.country && !b.country.valid) ||
        (b.age && !b.age.valid) ||
        (b.annualIncome && !b.annualIncome.valid) ||
        (b.employmentDate && !b.employmentDate.valid) ||
        (b.visaExpiry && !b.visaExpiry.valid) ||
        (b.healthInsurance && !b.healthInsurance.valid);
    
    // '가능' (no failure) comes before '불가' (has failure)
    if (!hasFailureA && hasFailureB) return -1;
    if (hasFailureA && !hasFailureB) return 1;
    
    // If both are '가능', sort by selected option
    if (!hasFailureA && !hasFailureB) {
        if (sortByRate) {
            // Sort by rate (lower rate first)
            const rateA = a.estimatedRate || 999;
            const rateB = b.estimatedRate || 999;
            return rateA - rateB;
        } else {
            // Sort by limit (higher limit first)
            const limitA = a.estimatedLimit || 0;
            const limitB = b.estimatedLimit || 0;
            return limitB - limitA;
        }
    }
    
    return 0;
});
```

**매개변수:**
- `a`: Object - 비교할 첫 번째 은행 정보 객체
  - `visaType`: 비자 종류 검증 결과
  - `country`: 국적 검증 결과
  - `age`: 나이 검증 결과
  - `annualIncome`: 연소득 검증 결과
  - `employmentDate`: 재직일자 검증 결과
  - `visaExpiry`: 비자 만료일 검증 결과
  - `healthInsurance`: 의료보험 검증 결과
  - `estimatedRate`: 예상 금리 (Number)
  - `estimatedLimit`: 예상 한도 (Number)
- `b`: Object - 비교할 두 번째 은행 정보 객체 (a와 동일한 구조)
- `sortByRate`: Boolean - 정렬 옵션 (true: 금리순, false: 한도순)

**반환값:**
- `Number`: 비교 결과
  - 음수(-1): a가 b보다 앞에 위치
  - 0: 같은 순위
  - 양수(1): a가 b보다 뒤에 위치

**정렬 기준:**
1. **1차 정렬:** 검증 통과 여부
   - '가능' 상태 (모든 검증 통과)인 은행이 '불가' 상태인 은행보다 먼저 표시
2. **2차 정렬:** 사용자 선택 옵션에 따라
   - **금리순 (sortByRate === true):**
     - `estimatedRate` 기준 오름차순 정렬 (낮은 금리 우선)
     - null 값은 999로 처리
   - **한도순 (sortByRate === false):**
     - `estimatedLimit` 기준 내림차순 정렬 (높은 한도 우선)
     - null 값은 0으로 처리

**사용 위치:**
- `displayLoanResult()` 함수 내
- 사용자가 라디오 버튼으로 정렬 옵션을 선택할 때 호출

**호출 방법:**
```javascript
// 정렬 옵션 확인
const sortByRate = document.querySelector('input[name="sortOption"]:checked')?.value === 'rate';

// 정렬 수행
const sortedBanks = result.banks.slice().sort((a, b) => {
    // ... 정렬 로직
});
```

---

## 2. 담보대출 정렬 함수/메소드

### 2.1 서버 측 정렬 메소드

#### 2.1.1 sortByRequestId() - 요청 ID 기준 정렬

**위치:** `server/src/main/java/com/loandoc/LoanDashboardServlet.java` (535-537줄)

**정의:**
```java
// Allow optional ordering by req_id. Default is DESC (new requirement).
String ord = (order != null && order.equalsIgnoreCase("asc")) ? "ASC" : "DESC";
sql.append(" ORDER BY req_id " + ord);
```

**매개변수:**
- `order`: String - 정렬 방향 ("asc" 또는 "desc", null인 경우 기본값 "desc")

**반환값:**
- SQL 쿼리 문자열에 정렬 절이 추가됨

**정렬 기준:**
- `req_id` 필드를 기준으로 정렬
- 기본값: 내림차순(DESC) - 최신 요청이 먼저 표시
- 선택값: 오름차순(ASC) - 오래된 요청이 먼저 표시

**사용 위치:**
- `LoanDashboardServlet.listRequests()` 메소드 내
- 데이터베이스 쿼리 생성 시 SQL ORDER BY 절에 추가

**SQL 쿼리 예시:**
```sql
-- 기본 정렬 (내림차순)
SELECT ... FROM loan_dashboard ... ORDER BY req_id DESC;

-- 오름차순 정렬
SELECT ... FROM loan_dashboard ... ORDER BY req_id ASC;
```

---

## 3. 정렬 함수/메소드 비교표

| 함수명 | 위치 | 정렬 기준 | 정렬 방향 | 우선순위 | 사용 시점 |
|--------|------|-----------|-----------|----------|-----------|
| `sortByRank()` | 서버 (Java) | rank | 오름차순 | - | 서버 응답 전 |
| `sortByInterestRate()` | 서버 (Java) | estimatedRate | 오름차순 | - | 은행 설정 초기화 시 |
| `sortBanksByOption()` | 클라이언트 (JavaScript) | estimatedRate 또는 estimatedLimit | 사용자 선택 | 1. 검증 통과 여부<br>2. 선택 옵션 | 화면 표시 시 |
| `sortByRequestId()` | 서버 (SQL) | req_id | 기본: 내림차순<br>선택: 오름차순 | - | 데이터베이스 쿼리 시 |

---

## 4. 정렬 함수 호출 흐름

### 4.1 신용대출 정렬 흐름

```
1. 서버 측:
   getBankConfigurations()
       ↓
   sortByInterestRate() - rank가 null인 은행들의 순위 결정
       ↓
   processBank() - 각 은행별 검증 및 계산
       ↓
   sortByRank() - 최종 rank 기준 정렬
       ↓
   클라이언트로 응답 전송

2. 클라이언트 측:
   displayLoanResult()
       ↓
   sortBanksByOption() - 사용자 선택에 따른 정렬
       ↓
   화면에 표시
```

### 4.2 담보대출 정렬 흐름

```
1. 서버 측:
   listRequests()
       ↓
   sortByRequestId() - SQL ORDER BY 절 추가
       ↓
   데이터베이스에서 정렬된 결과 조회
       ↓
   클라이언트로 응답 전송

2. 클라이언트 측:
   renderPosts() - 서버에서 정렬된 결과를 그대로 표시
```

---

## 5. 정렬 함수 사용 예시

### 5.1 신용대출 - 금리순 정렬

```javascript
// 사용자가 "금리순" 라디오 버튼 선택
const sortByRate = true;

// 정렬 수행
const sortedBanks = result.banks.slice().sort((a, b) => {
    // 검증 통과 여부 확인
    const hasFailureA = /* ... */;
    const hasFailureB = /* ... */;
    
    // '가능' 우선 정렬
    if (!hasFailureA && hasFailureB) return -1;
    if (hasFailureA && !hasFailureB) return 1;
    
    // 둘 다 '가능'인 경우 금리순 정렬
    if (!hasFailureA && !hasFailureB) {
        const rateA = a.estimatedRate || 999;
        const rateB = b.estimatedRate || 999;
        return rateA - rateB; // 오름차순
    }
    
    return 0;
});
```

### 5.2 신용대출 - 한도순 정렬

```javascript
// 사용자가 "한도순" 라디오 버튼 선택
const sortByRate = false;

// 정렬 수행
const sortedBanks = result.banks.slice().sort((a, b) => {
    // 검증 통과 여부 확인
    const hasFailureA = /* ... */;
    const hasFailureB = /* ... */;
    
    // '가능' 우선 정렬
    if (!hasFailureA && hasFailureB) return -1;
    if (hasFailureA && !hasFailureB) return 1;
    
    // 둘 다 '가능'인 경우 한도순 정렬
    if (!hasFailureA && !hasFailureB) {
        const limitA = a.estimatedLimit || 0;
        const limitB = b.estimatedLimit || 0;
        return limitB - limitA; // 내림차순
    }
    
    return 0;
});
```

### 5.3 담보대출 - 최신순 정렬

```java
// 서버 측
String order = null; // 기본값
String ord = (order != null && order.equalsIgnoreCase("asc")) ? "ASC" : "DESC";
sql.append(" ORDER BY req_id " + ord);
// 결과: "ORDER BY req_id DESC" - 최신 요청이 먼저 표시
```

---

## 6. 참고사항

1. **신용대출 정렬 특징:**
   - 서버는 기본적으로 rank 기준으로 정렬하여 응답
   - 클라이언트에서 사용자 선택에 따라 한도순 또는 금리순으로 재정렬
   - '가능' 상태인 은행이 항상 '불가' 상태인 은행보다 먼저 표시됨
   - 동일한 값일 때 같은 순위 부여 (예: 1, 2, 2, 4, 5)

2. **담보대출 정렬 특징:**
   - 서버 측에서 req_id 기준 내림차순 정렬 (최신순)
   - 클라이언트 측 추가 정렬 없음
   - 검색 및 필터링 기능 제공

3. **성능 최적화:**
   - 신용대출: 정렬 옵션 변경 시 서버 재요청 없이 클라이언트 측에서 정렬 처리
   - 담보대출: 데이터베이스 레벨에서 정렬 처리하여 효율성 확보

4. **정렬 안정성:**
   - 모든 정렬 함수는 안정적 정렬(stable sort)을 보장
   - 동일한 값일 때 원래 순서 유지




